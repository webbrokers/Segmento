
(function(){
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
  const angleTo=(x1,y1,x2,y2)=>Math.atan2(y2-y1,x2-x1);
  function seedRand(seed=1){let s=seed%2147483647;if(s<=0)s+=2147483646;return()=> (s=s*16807%2147483647)/2147483647}
  const cvs=document.getElementById('game'), ctx=cvs.getContext('2d');
  const mm=document.getElementById('minimap'), mctx=mm.getContext('2d');
  const fuelFill=document.getElementById('fuelFill'), hpFill=document.getElementById('hpFill');
  const countdownEl=document.getElementById('countdown');
  const startBtn=document.getElementById('startBtn'), mapSelect=document.getElementById('mapSelect'), tankSelect=document.getElementById('tankSelect');
  const cfgFps=document.getElementById('cfg_fps'), mapUrl=document.getElementById('mapUrl'), mapFile=document.getElementById('mapFile');
  const hullUrl=document.getElementById('hullUrl'), turretUrl=document.getElementById('turretUrl'), hullFile=document.getElementById('hullFile'), turretFile=document.getElementById('turretFile');
  const MAP_BASE_SIZE=1920, VIEW={x:0,y:0,scale:1}, WORLD={w:MAP_BASE_SIZE,h:MAP_BASE_SIZE};
  const STATE={running:false,lastTick:0,acc:0,renderAcc:0,startTime:0,elapsed:0};
  const cfg=getConfig(); cfgFps.value=cfg.fps;
  const keys={}; window.addEventListener('keydown',e=>{keys[e.code]=true; if(e.code==='Space') e.preventDefault()}); window.addEventListener('keyup',e=>{keys[e.code]=false});
  let mouse={x:0,y:0}; cvs.addEventListener('mousemove',e=>{const r=cvs.getBoundingClientRect(); mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top}); cvs.addEventListener('wheel',e=>{const d=Math.sign(e.deltaY); cfg.camScale=clamp(cfg.camScale+(-d)*5,50,150); setConfig(cfg)});
  let player, enemy, bullets=[], barrels=[], obstacles=[], effects=[], mapBgImg=null, hullImg=null, turretImg=null;
  function loadImage(src){return new Promise((res,rej)=>{const img=new Image(); img.crossOrigin="anonymous"; img.onload=()=>res(img); img.onerror=rej; img.src=src})}
  function fileToImage(f){return new Promise((res,rej)=>{const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=URL.createObjectURL(f)})}
  startBtn.onclick=async()=>{ cfg.fps=clamp(parseInt(cfgFps.value||'15'),5,60); setConfig(cfg); await prepareAssets(); resetMatch(); doCountdown(()=>{ STATE.running=true; STATE.lastTick=performance.now(); STATE.acc=0; STATE.renderAcc=0; STATE.startTime=performance.now(); STATE.elapsed=0; scheduleBarrelSpawner(); loop(); }); };
  async function prepareAssets(){ mapBgImg=null; if(mapSelect.value==='url' && mapUrl.value.trim()){ mapBgImg=await loadImage(mapUrl.value.trim()) } else if(mapSelect.value==='upload' && mapFile.files[0]){ mapBgImg=await fileToImage(mapFile.files[0]) } hullImg=null; turretImg=null; if(tankSelect.value==='custom'){ if(hullFile.files[0]) hullImg=await fileToImage(hullFile.files[0]); else if(hullUrl.value.trim()) hullImg=await loadImage(hullUrl.value.trim()); if(turretFile.files[0]) turretImg=await fileToImage(turretFile.files[0]); else if(turretUrl.value.trim()) turretImg=await loadImage(turretUrl.value.trim()); } }
  let GROUND_COLOR="#e6efe6", OBST_COLOR="#b7c3b7"; function genProceduralMap(kind='proc-1'){ obstacles=[]; barrels=[]; effects=[]; bullets=[]; const scale=cfg.mapScale/100; WORLD.w=Math.floor(MAP_BASE_SIZE*scale); WORLD.h=Math.floor(MAP_BASE_SIZE*scale); const lb=kind==='proc-1'?'#e6efe6':(kind==='proc-2'?'#ece6d6':'#e7ebf2'); GROUND_COLOR=lb; OBST_COLOR=kind==='proc-1'?'#b7c3b7':(kind==='proc-2'?'#c9bea6':'#bfc8d6'); const rnd=seedRand(kind==='proc-1'?1:(kind==='proc-2'?2:3)); const count=Math.floor((18+rnd()*10)/2); for(let i=0;i<count;i++){ const w=(140+rnd()*220)*0.6, h=(100+rnd()*200)*0.6, x=rnd()*(WORLD.w-w-100)+50, y=rnd()*(WORLD.h-h-100)+50; obstacles.push({x,y,w,h}) } }
  function spawnBarrel(){ for(let tries=0; tries<20; tries++){ const r=12, x=Math.random()*(WORLD.w-2*r)+r, y=Math.random()*(WORLD.h-2*r)+r; const o=obstacles.find(o=>x>o.x-r&&x<o.x+o.w+r&&y>o.y-r&&y<o.y+o.h+r); if(!o){barrels.push({x,y,r:12,alive:true}); return} } }
  function resetMatch(){ if(!mapBgImg) genProceduralMap(mapSelect.value); else { obstacles=[]; barrels=[]; effects=[]; bullets=[]; WORLD.w=Math.floor(MAP_BASE_SIZE*(cfg.mapScale/100)); WORLD.h=Math.floor(MAP_BASE_SIZE*(cfg.mapScale/100)) } const s=28; player={name:'Игрок',color:'green',x:s+80,y:WORLD.h-s-80,dir:0,turret:0,size:s,fuel:100,hp:100,lives:cfg.lives,canFireAt:0}; enemy={name:'ИИ',color:'sand',x:WORLD.w-s-80,y:s+80,dir:Math.PI,turret:Math.PI,size:s,fuel:100,hp:100,lives:cfg.lives,canFireAt:0,ai:{thinkAt:0}}; for(let i=0;i<2;i++) spawnBarrel(); VIEW.x=0; VIEW.y=0; VIEW.scale=cfg.camScale/100; }
  function sample(){ return {up:keys['KeyW']||keys['ArrowUp'],down:keys['KeyS']||keys['ArrowDown'],left:keys['KeyA']||keys['ArrowLeft'],right:keys['KeyD']||keys['ArrowRight'],fire:keys['Space']} }
  function moveTank(t,dt,input){ t.fuel=clamp(t.fuel-cfg.fuelRate*dt,0,100); const speedF=cfg.speedF, speedB=cfg.speedB, turn=cfg.turn; let forward=0; if(input.up) forward+=1; if(input.down) forward-=1; if(t.fuel<=0) forward=0; let turnDir=0; if(input.left) turnDir-=1; if(input.right) turnDir+=1; t.dir+=turn*turnDir*dt; const spd=forward>0?speedF:(forward<0?speedB:0); const vx=Math.cos(t.dir)*spd*forward, vy=Math.sin(t.dir)*spd*forward; let nx=t.x+vx*dt, ny=t.y+vy*dt; const r=t.size, rect={x:nx-r,y:ny-r,w:r*2,h:r*2}; if(rect.x<0) nx=r; if(rect.y<0) ny=r; if(rect.x+rect.w>WORLD.w) nx=WORLD.w-r; if(rect.y+rect.h>WORLD.h) ny=WORLD.h-r; for(const o of obstacles){ if(!(rect.x+rect.w<o.x||rect.x>o.x+o.w||rect.y+rect.h<o.y||rect.y>o.y+o.h)){ if(t.x<o.x) nx=o.x-r; if(t.x>o.x+o.w) nx=o.x+o.w+r; if(t.y<o.y) ny=o.y-r; if(t.y>o.y+o.h) ny=o.y+o.h+r } } t.x=nx; t.y=ny; let ang=t.turret; const wx=VIEW.x+(mouse.x/VIEW.scale), wy=VIEW.y+(mouse.y/VIEW.scale); ang=Math.atan2(wy-t.y,wx-t.x); const da=((ang-t.turret+Math.PI*3)%(Math.PI*2))-Math.PI; t.turret+=Math.max(-cfg.turretTurn*dt, Math.min(cfg.turretTurn*dt, da)); for(const b of barrels) if(b.alive && dist2(t.x,t.y,b.x,b.y)<t.size+b.r){ b.alive=false; t.fuel=clamp(t.fuel+cfg.fuelGain,0,100) } }
  function fire(t){ const now=performance.now(); if(now<t.canFireAt) return; t.canFireAt=now+cfg.reload; const spd=cfg.bulletSpeed, ang=t.turret, r=t.size+6; bullets.push({from:t,x:t.x+Math.cos(ang)*r,y:t.y+Math.sin(ang)*r,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,alive:true,life:2.0}) }
  function updateBullets(dt){ for(const blt of bullets) if(blt.alive){ blt.x+=blt.vx*dt; blt.y+=blt.vy*dt; blt.life-=dt; if(blt.life<=0||blt.x<0||blt.y<0||blt.x>WORLD.w||blt.y>WORLD.h) blt.alive=false; const rect={x:blt.x-2,y:blt.y-2,w:4,h:4}; for(const o of obstacles){ if(!(rect.x+rect.w<o.x||rect.x>o.x+o.w||rect.y+rect.h<o.y||rect.y>o.y+o.h)){ blt.alive=false; break } } for(const t of [player,enemy]) if(blt.alive && blt.from!==t){ if(dist2(blt.x,blt.y,t.x,t.y)<t.size){ blt.alive=false; t.hp=clamp(t.hp-cfg.bulletDmg,0,100); if(t.hp<=0){ t.lives-=1; t.hp=100; if(t.lives<=0) endMatch(t===player?'enemy':'player') } } } for(const b of barrels) if(blt.alive && b.alive){ if(dist2(blt.x,blt.y,b.x,b.y)<b.r+3){ blt.alive=false; b.alive=false; for(const t of [player,enemy]){ if(dist2(t.x,t.y,b.x,b.y)<=cfg.barrelRad){ t.hp=clamp(t.hp-cfg.barrelDmg,0,100); if(t.hp<=0){ t.lives-=1; t.hp=100; if(t.lives<=0) endMatch(t===player?'enemy':'player') } } } } } } }
  function endMatch(winner){ STATE.running=false; const elapsed=(performance.now()-STATE.startTime)/1000; const scores=getScores(); if(winner==='player'){ scores.push({name:'Игрок',wins:1,timeSec:elapsed}); scores.sort((a,b)=>a.timeSec-b.timeSec); setScores(scores); alert('Победа!') } else alert('Поражение!') }
  function aiThink(t,dt){ const now=performance.now(); if(now<(t.ai.thinkAt||0)) return; t.ai.thinkAt=now+250; let goal=null; if(t.fuel<40 && barrels.some(b=>b.alive)){ let best=null, bd=1e9; for(const b of barrels) if(b.alive){ const d=dist2(t.x,t.y,b.x,b.y); if(d<bd){bd=d; best=b} } if(best) goal={x:best.x,y:best.y} } else { const d=dist2(t.x,t.y,player.x,player.y); const ang=Math.atan2(player.y-t.y,player.x-t.x); const da=Math.abs(((ang - t.turret + Math.PI*3)%(Math.PI*2))-Math.PI); if(da<0.12) fire(t); goal = d>320 ? {x:player.x,y:player.y} : {x:player.x+Math.cos(ang+Math.PI/2)*140,y:player.y+Math.sin(ang+Math.PI/2)*140}; } if(goal){ const angGoal=Math.atan2(goal.y-t.y,goal.x-t.x); const da=((angGoal - t.dir + Math.PI*3)%(Math.PI*2))-Math.PI; const input=t._input||(t._input={up:false,down:false,left:false,right:false}); input.up=true; input.down=false; input.left=da<0; input.right=da>0 } }
  function updateCamera(dt){ VIEW.scale=cfg.camScale/100; const vw=cvs.width, vh=cvs.height, pad=28*2; const left=(player.x-VIEW.x)*VIEW.scale, top=(player.y-VIEW.y)*VIEW.scale, right=vw-left, bottom=vh-top; let dx=0,dy=0; if(left<pad) dx=-(pad-left)/VIEW.scale; if(right<pad) dx=(pad-right)/VIEW.scale; if(top<pad) dy=-(pad-top)/VIEW.scale; if(bottom<pad) dy=(pad-bottom)/VIEW.scale; VIEW.x=clamp(VIEW.x+dx,0,Math.max(0,WORLD.w - vw/VIEW.scale)); VIEW.y=clamp(VIEW.y+dy,0,Math.max(0,WORLD.h - vh/VIEW.scale)) }
  function updateEffects(dt){}
  function loop(){ if(!STATE.running) return; const now=performance.now(); let dt=(now-STATE.lastTick)/1000; STATE.lastTick=now; STATE.acc+=dt; STATE.renderAcc+=dt; STATE.elapsed=(now-STATE.startTime)/1000; while(STATE.acc>=1/60){ const inp=sample(); if(inp.fire) fire(player); moveTank(player,1/60,inp); aiThink(enemy,1/60); moveTank(enemy,1/60, enemy._input||{up:false,down:false,left:false,right:false}); updateBullets(1/60); updateEffects(1/60); updateCamera(1/60); STATE.acc-=1/60 } const step=1/Math.max(5,Math.min(60,parseInt(cfg.fps)||15)); if(STATE.renderAcc>=step){ render(); STATE.renderAcc=0 } requestAnimationFrame(loop) }
  function resize(){ const r=cvs.getBoundingClientRect(); const w=Math.floor(r.width), h=Math.floor(r.height); if(cvs.width!==w||cvs.height!==h){cvs.width=w; cvs.height=h} }
  function render(){ resize(); const vw=cvs.width, vh=cvs.height; ctx.clearRect(0,0,vw,vh); ctx.save(); ctx.scale(VIEW.scale,VIEW.scale); ctx.translate(-VIEW.x,-VIEW.y);
    if(mapBgImg) ctx.drawImage(mapBgImg,0,0,WORLD.w,WORLD.h); else { ctx.fillStyle='#e6efe6'; ctx.fillRect(VIEW.x,VIEW.y,vw/VIEW.scale,vh/VIEW.scale) }
    ctx.fillStyle='#b7c3b7'; for(const o of obstacles) ctx.fillRect(o.x,o.y,o.w,o.h);
    const fogRad=(28* getConfig().fogRadiusUnits);
    for(const b of barrels) if(b.alive && dist2(player.x,player.y,b.x,b.y)<=fogRad){ ctx.fillStyle='#b38c2e'; ctx.beginPath(); ctx.arc(b.x,b.y,12,0,Math.PI*2); ctx.fill() }
    if(dist2(player.x,player.y,enemy.x,enemy.y)<=fogRad) drawTank(enemy);
    drawTank(player);
    for(const blt of bullets) if(blt.alive){ if(blt.from===player || dist2(player.x,player.y,blt.x,blt.y)<=fogRad){ ctx.fillStyle='#996b00'; ctx.fillRect(blt.x-2,blt.y-2,4,4) } }
    const darkness=Math.max(0,Math.min(0.9,getConfig().fogDark/100)); ctx.fillStyle=`rgba(0,0,0,${darkness})`; ctx.fillRect(VIEW.x,VIEW.y,vw/VIEW.scale,vh/VIEW.scale);
    const grd=ctx.createRadialGradient(player.x,player.y,fogRad*0.6,player.x,player.y,fogRad); grd.addColorStop(0,'rgba(0,0,0,0)'); grd.addColorStop(1,`rgba(0,0,0,${darkness})`);
    ctx.globalCompositeOperation='destination-out'; ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(player.x,player.y,fogRad,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha=.6; ctx.fillStyle='#98a2b3'; for(const o of obstacles) ctx.fillRect(o.x,o.y,o.w,o.h); ctx.globalAlpha=1;
    ctx.restore();
    fuelFill.style.width = player.fuel.toFixed(1)+'%'; hpFill.style.width = player.hp.toFixed(1)+'%';
    renderMinimap();
  }
  function renderMinimap(){ const s=Math.min(mm.width,mm.height); mctx.clearRect(0,0,mm.width,mm.height); mctx.fillStyle='#0c0f14'; mctx.fillRect(0,0,mm.width,mm.height); mctx.strokeStyle='#1f2633'; mctx.strokeRect(0.5,0.5,mm.width-1,mm.height-1); const sx=s/WORLD.w, sy=s/WORLD.h; mctx.fillStyle='#98a2b3'; for(const o of obstacles) mctx.fillRect(o.x*sx,o.y*sy,o.w*sx,o.h*sy); mctx.fillStyle='#b38c2e'; for(const b of barrels) if(b.alive) mctx.fillRect(b.x*sx-1,b.y*sy-1,2,2); mctx.fillStyle='#00e37d'; mctx.fillRect(player.x*sx-2,player.y*sy-2,4,4); mctx.fillStyle='#ff3b30'; mctx.fillRect(enemy.x*sx-2,enemy.y*sy-2,4,4); mctx.strokeStyle='#4aa3ff'; mctx.lineWidth=1; mctx.strokeRect(VIEW.x*sx,VIEW.y*sy,(cvs.width/VIEW.scale)*sx,(cvs.height/VIEW/scale)*sy) }
  function drawTank(t){ ctx.save(); ctx.translate(t.x,t.y); ctx.rotate(t.dir); const w=t.size*2, h=t.size*1.6; ctx.fillStyle='#2a3347'; ctx.fillRect(-w/2,-h/2,w,h); ctx.fillStyle=(t.color==='green')?'#58c98b':'#e8c89b'; ctx.fillRect(-w*0.45,-h*0.35,w*0.9,h*0.7); ctx.fillStyle='#111822'; ctx.beginPath(); ctx.moveTo(w*0.5,0); ctx.lineTo(w*0.2,-h*0.25); ctx.lineTo(w*0.2,h*0.25); ctx.closePath(); ctx.fill(); ctx.rotate(-t.dir); ctx.rotate(t.turret);
    if(tankSelect.value==='custom' && turretImg){ const scale=.5; const tw=w*scale, th=w*scale; ctx.drawImage(turretImg, -tw*0.2, -th*0.5, tw, th) } else { ctx.fillStyle='#222832'; ctx.fillRect(-6,-6,12,12); ctx.fillStyle='#bcc7d9'; ctx.fillRect(0,-2,t.size,4) } ctx.restore(); }
  function doCountdown(cb){ let n=3; countdownEl.textContent=n; countdownEl.classList.add('active'); const t=setInterval(()=>{ n--; if(n>0) countdownEl.textContent=n; else { countdownEl.textContent='СТАРТ'; setTimeout(()=>{ countdownEl.classList.remove('active'); cb&&cb() },600); clearInterval(t) } },700) }
  let barrelTimer=null; function scheduleBarrelSpawner(){ if(barrelTimer) clearInterval(barrelTimer); barrelTimer=setInterval(spawnBarrel, Math.max(500, getConfig().barrelSpawn|0)) }
  cvs.addEventListener('mousedown',()=>{ if(STATE.running) fire(player) });
})();
